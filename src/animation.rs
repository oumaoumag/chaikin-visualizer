use macroquad::math::Vec2;
use macroquad::prelude::*;

use crate::chaikin;

// Represents the current state of the application
pub enum AppState {
    Drawing,    // User is drawing control points
    Animating, // Animation is playing
    Paused,    // Animation is paused
}

// Manages the animation and state of the application
pub struct AnimationManager {
    pub points: Vec<Vec2>,                    // Control points drawn by the user
    pub state: AppState,                      // Current application state
    pub animation_steps: Vec<Vec<Vec2>>,      // All animation steps generated by Chaikin's algorithm
    pub current_step: usize,                  // Current step being displayed
    pub animation_timer: f32,                 // Timer for animation transitions
    pub animation_speed: f32,                 // Speed of animation in seconds per step
    pub dragging_point_index: Option<usize>,  // Stores point being dragged (if any)
    pub drag_threshold: f32,                  // How close to a point the mouse needs to be (in pixels) to select it
}

impl Default for AnimationManager {
    // Creates a new animation manager with default values
    fn default() -> Self {      
        Self {
            points: Vec::new(),
            state: AppState::Drawing,
            animation_steps: Vec::new(),
            current_step: 0,
            animation_timer: 0.0,
            animation_speed: 0.5,
            dragging_point_index: None,
            drag_threshold: 10.0, // Distance in pixexls todetect point selection
        }
    }
}

impl AnimationManager {

    pub fn new() -> Self {
        Self::default()
    }
        // Adds a point to the list of control points
    pub fn add_point(&mut self, position: Vec2) {
        self.points.push(position);
    }

    // Starts the animation by calculating all steps of Chaikin's algorithm
    // Uses a ratio of 0.25 and 7 iterations for smooth curve generation
    pub fn start_animation(&mut self) {
        if self.points.len() >= 3 {
            self.animation_steps = chaikin::apply_chaikin(&self.points, 7, 0.25);
            self.current_step = 0;
            self.animation_timer = 0.0;
            self.state = AppState::Animating;
        }
    }

    // Toggles the animation between paused and playing states
    pub fn toggle_animation_pause(&mut self) {
        match self.state {
            AppState::Animating => self.state = AppState::Paused,
            AppState::Paused => self.state = AppState::Animating,
            AppState::Drawing => (),
        }
    }

    // Updates the animation state based on elapsed time
    pub fn update(&mut self, dt: f32) {
        match self.state {
            AppState::Drawing => {}
            AppState::Animating => {
                self.animation_timer += dt;

                if self.animation_timer >= self.animation_speed {
                    self.animation_timer = 0.0;
                    self.current_step = (self.current_step + 1) % self.animation_steps.len();
                }
            }
            AppState::Paused => {} // Do nothing when paused
        }
    }

    // Draws the current state of the application
    // Renders different elements based on whether we're in drawing or animation mode
    pub fn draw(&self) {
        clear_background(Color::new(0.1, 0.1, 0.1, 1.0));

        match self.state {
            AppState::Drawing => {
                // Draw points
                for point in &self.points {
                    draw_circle(point.x, point.y, 5.0, RED);
                }

                // Draw lines between points
                if self.points.len() >= 2 {
                    for i in 0..self.points.len() - 1 {
                        draw_line(
                            self.points[i].x,
                            self.points[i].y,
                            self.points[i + 1].x,
                            self.points[i + 1].y,
                            2.0,
                            WHITE,
                        );
                    }

                    if self.points.len() >= 3 {
                        let last = self.points.len() - 1;
                        draw_line(
                            self.points[last].x,
                            self.points[last].y,
                            self.points[0].x,
                            self.points[0].y,
                            2.0,
                            WHITE,
                        );
                    }
                }

                draw_text(
                    "Click to add points. Press Enter to start animation. Press R to reset. Press Escape to quit.",
                    20.0,
                    20.0,
                    20.0,
                    WHITE,
                );
            }
            AppState::Animating | AppState::Paused => {
                let current_points = &self.animation_steps[self.current_step];

                // Draw points
                for point in current_points {
                    draw_circle(point.x, point.y, 3.0, BLUE);
                }

                // Draw lines
                if current_points.len() >= 2 {
                    for i in 0..current_points.len() - 1 {
                        draw_line(
                            current_points[i].x,
                            current_points[i].y,
                            current_points[i + 1].x,
                            current_points[i + 1].y,
                            2.0,
                            GREEN,
                        );
                    }

                    let last = current_points.len() - 1;
                    draw_line(
                        current_points[last].x,
                        current_points[last].y,
                        current_points[0].x,
                        current_points[0].y,
                        2.0,
                        GREEN,
                    );
                }

                let status = if matches!(self.state, AppState::Paused) {
                    "PAUSED"
                } else {
                    "Playing"
                };

                draw_text(
                    &format!("Step: {}/{} ({})", self.current_step, self.animation_steps.len() - 1, status),
                    20.0,
                    20.0,
                    20.0,
                    WHITE,
                );

                draw_text(
                    "Space to pause/resume. Press R to reset. Press Escape to quit.",
                    20.0,
                    50.0,
                    20.0,
                    WHITE,
                );
            }
        }
    }


    // Attempts to start dragging a control point near the given mouse position
    pub fn start_dragging(&mut self, mouse_pos: Vec2) {
        if let AppState::Drawing = self.state {
            self.dragging_point_index = self.find_closest_point(mouse_pos);
        }
    }

    // Updates the position of the currently dragged point
    pub fn update_dragging(&mut self, mouse_pos: Vec2) {
        if let Some(index) = self.dragging_point_index {
            self.points[index] = mouse_pos;
        }
    }

    // Stops the point dragging operation
    pub fn stop_dragging(&mut self) {
        self.dragging_point_index = None;
    }

    // Finds the closest control point to the given mouse position
    fn find_closest_point(&self, mouse_pos: Vec2) -> Option<usize> {
        self.points
            .iter()
            .enumerate()
            .map(|(i, &p)| (i, (p - mouse_pos).length()))
            .filter(|&(_, dist)| dist <= self.drag_threshold)
            .min_by(|a, b| a.1.partial_cmp(&b.1).unwrap())
            .map(|(i, _)| i)
    }

    // Resets the application to the drawing state
    // Clears all points and animation data
    pub fn reset(&mut self) {
        self.points.clear();
        self.animation_steps.clear();
        self.current_step = 0;
        self.animation_timer = 0.0;
        self.state = AppState::Drawing;
    }
}
